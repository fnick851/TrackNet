<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>TrackNet: Bubbles View</title>
<script type="text/javascript" src="../lib/d3.min.js"></script>
<script type="text/javascript" src="../lib/d3-transform.js"></script>
<script type="text/javascript" src="../lib/jquery-2.1.3.min.js"></script>
</head>
<body>
	<script type="text/javascript">
		var canvasWidth = 1000,
			canvasHeight = 1000;
		var colors = d3.scale.category10();
		var svg = d3.select("body")
		            .append("svg")
		            .attr("width", canvasWidth)
		            .attr("height", canvasHeight);
		
		var completeData;
		
		var p1Info;
		var bubbleData = [];
		var bubbleCenter = [300,250];
		var bigRadius = 100;
		var smallRadius = 50;
		var bubbleSizeRange = [20, 50];
		var bubbleScale;
		var shrinkRadius = 20;
		var rightMostAngleRel = 0;
		var rightMostAngleAbs = 0;
		
		var boxTopLeft = [600,60];
		var boxDimentions = [250,420];
		var boxVisibleCapacity = 10;
		
		//d3.json("data.json", function(error, root) {
		d3.json("data/851.adjacency.json", function(error, root) {
			completeData = root;
			p1Info = root.firstPartyDomains[1004];
			for (var i = 0; i < p1Info.catList.length; i++) {
				bubbleData.push({ "index": i,
								  "id": p1Info.catList[i],
								  "category": root.catList[p1Info.catList[i]],
								  "size": p1Info[p1Info.catList[i]].length });
			}
			drawGraph();
		});
		
		function computeBubblePositions() {
			var bigBubbleIdx = [-1,-1];
			var smallBubbleIdx = [-1,-1];
			var sizeRange = [-1,-1];
			for (var i = 0; i < bubbleData.length; i++) {
				if (bubbleData[i].shrink != true) {
					if (sizeRange[1] < 0) {
						sizeRange[1] = bubbleData[i].size;
					}
					sizeRange[0] = bubbleData[i].size;
				}
			}
			bubbleScale = d3.scale.sqrt()
							.domain(sizeRange)
							.range(bubbleSizeRange);
			for (var i = 0; i < bubbleData.length; i++) {
				if (bubbleData[i].shrink != true) {
					bubbleData[i].R = bigRadius;
					bubbleData[i].r = bubbleScale(bubbleData[i].size);
					bigBubbleIdx = computeAngle(i, bigBubbleIdx[0], bigBubbleIdx[1]);
				} else {
					bubbleData[i].R = smallRadius;
					bubbleData[i].r = shrinkRadius;
					smallBubbleIdx = computeAngle(i, smallBubbleIdx[0], smallBubbleIdx[1]);
				}
			}
		}
		
		function computeAngle(i, preIdx, firstIdx) {
			if (firstIdx < 0) {
				bubbleData[i].angle = 0;
				return [i,i];
			} else {
				var angle = bubbleAngle(bubbleData[i].R, bubbleData[preIdx].r, bubbleData[i].r);
				var angleCC = bubbleAngle(bubbleData[i].R, bubbleData[firstIdx].r, bubbleData[i].r);
				if (angle + bubbleData[preIdx].angle <= 2 * Math.PI - angleCC) {
					bubbleData[i].angle = angle + bubbleData[preIdx].angle;
					preIdx = i;
				} else {
					bubbleData[i].angle = bubbleData[preIdx].angle;
				}
				return [preIdx,firstIdx];	
			}
		}
		
		function bubbleAngle(R, r1, r2) {
			var a = r1 + r1/10 + r2;
			var b = R + r1;
			var c = R + r2;
			return Math.acos((Math.pow(b,2)+Math.pow(c,2)-Math.pow(a,2))/(2*b*c));
		}
		
		function shrinkTransition(token, data) {
			token.transition()
				 .attr("cx", bubbleCenter[0] + (data.R + data.r) * Math.cos(data.angle))
				 .attr("cy", bubbleCenter[1] + (data.R + data.r) * Math.sin(data.angle))
				 .attr("r", data.r)
				 .each("end", function() {
					 reDrawBubbles();
				 });
		}
		
		function reDrawBubbles() {
			computeBubblePositions();
			svg.selectAll(".catgoryBubble")
			   .data(bubbleData)
			   .select("circle")
			   .transition()
			   .attr("cx", function(d, i) {
				   d.angle = d.angle - rightMostAngleAbs
				   return bubbleCenter[0] + (d.R + d.r) * Math.cos(d.angle);
			   })
			   .attr("cy", function(d, i) {
				   return bubbleCenter[1] + (d.R + d.r) * Math.sin(d.angle);
			   })
			   .attr("r", function(d) {
				   return d.r;
			   });
		}
		
		function drawTriangle(offset, rotate, index, visibility) {
			var dim = 20;
			if (rotate == 90 || rotate == 180) {
				offset[0] += dim;
			}
			if (rotate == 180 || rotate == 270) {
				offset[1] += dim;
			}
			var transform = d3.svg.transform()
							  .translate(offset)
							  .rotate(rotate);
			return d3.select("#trackersBox")
					 .append("polygon")
					 .attr("points", "0,0 "+dim+",0 "+dim/2+","+dim)
					 .attr("fill", colors(index))
					 .attr("visibility", visibility)
					 .attr('transform', transform)
					 .on("mouseover", function() {
						 d3.select(this).attr("opacity", 0.2);
					 })
					 .on("mouseout", function() {
						 d3.select(this).attr("opacity", null);
					 });
		}
		
		function drawTrackersList(token, data) {
			token.append("text")
				 .attr("x", boxTopLeft[0]+boxDimentions[0]/2)
				 .attr("y", boxTopLeft[1]+50)
				 .attr("fill", colors(data.index))
				 .style("text-anchor", "middle")
				 .text(data.category);
			
			var boxData = [""];
			for (var i = 0; i < boxVisibleCapacity && i < p1Info[data.id].length; i++) {
				boxData.push(completeData.domainList[p1Info[data.id][i]]);
			}
			
			console.log(boxData);
			token.selectAll("text")
				 .data(boxData)
				 .enter()
				 .append("text")
				 .attr("x", boxTopLeft[0]+20)
				 .attr("y", function(d, i) {
					 return boxTopLeft[1]+60+30*i;
				 })
				 .text(function(d) {
					 return d;
				 });
		}
		
		function drawGraph() {
			computeBubblePositions();
			svg.selectAll("circle")
			   .data(bubbleData)
			   .enter()
			   .append("g")
			   .attr("class", "catgoryBubble")
			   .append("circle")
			   .attr("cx", function(d, i) {
				   return bubbleCenter[0] + (d.R + d.r) * Math.cos(d.angle);
			   })
			   .attr("cy", function(d, i) {
				   return bubbleCenter[1] + (d.R + d.r) * Math.sin(d.angle);
			   })
			   .attr("r", function(d) {
				   return d.r;
			   })
			   .attr("fill", function(d, i) {
				   return colors(i);
			   })
			   .attr("opacity", 0.7)
			   .on("click", function(data) {
				   if (data.shrink != true) {
					   if (d3.mouse(this)[1] > d3.select(this).attr("cy")-d3.select(this).attr("r")/2) {
						   // Move a bubble to the right-most position.
						   rightMostAngleRel = data.angle;
						   rightMostAngleAbs += data.angle;
						   var toRightCount = 0;
						   svg.selectAll(".catgoryBubble")
						      .select("circle")
						      .transition()
						      .attr("cx", function(d, i) {
						    	  d.angle = d.angle - rightMostAngleRel;
						    	  return bubbleCenter[0] + (d.R + d.r) * Math.cos(d.angle);
						      })
						      .attr("cy", function(d, i) {
						    	  return bubbleCenter[1] + (d.R + d.r) * Math.sin(d.angle);
						      })
						      .each("start", function() {
						    	  toRightCount++;
						      })
						      .each("end", function() {
						    	  // Show the trackers' box.
						    	  if ( --toRightCount != 0 )
						    		  return;
						    	  var trackersBox = svg.append("g")
						    	  					   .attr("id", "trackersBox");
						    	  
						    	  trackersBox.append("rect")
						    	  			 .attr("x", boxTopLeft[0])
						    	  			 .attr("y", boxTopLeft[1])
						    	  			 .attr("rx", 40)
						    	  			 .attr("ry", 40)
						    	  			 .attr("width", boxDimentions[0])
						    	  			 .attr("height", boxDimentions[1])
						    	  			 .attr("fill", "none")
						    	  			 .attr("stroke", colors(data.index));
						    	  
						    	  var navOffset = 10;
						    	  var triLeft = drawTriangle([boxTopLeft[0]+45,boxTopLeft[1]+navOffset], 90, data.index, null);
						    	  triLeft.on("click", function() {
						    		  d3.select("#trackersBox").remove();
						    	  });
						    	  drawTriangle([boxTopLeft[0]+115,boxTopLeft[1]+navOffset], 0, data.index, "hidden");
						    	  drawTriangle([boxTopLeft[0]+185,boxTopLeft[1]+navOffset], 270, data.index, null);
						    	  
						    	  drawTrackersList(trackersBox, data)
						      });
						   d3.select("#closeButton").remove();
						   d3.select("#categoryTooltip").remove();
						   d3.select("#trackersBox").remove();
					   } else {
						   // Shrink a bubble
						   data.shrink = bubbleData[data.index].shrink = true;
						   data.R = smallRadius;
						   data.r = shrinkRadius;
						   shrinkTransition(d3.select(this), data);
						   d3.select("#closeButton").remove();
						   d3.select("#categoryTooltip").remove();
						   d3.select("#trackersBox").remove();
					   }
				   } else {
					   // Expand a bubble
					   data.shrink = bubbleData[data.index].shrink = false;
					   data.R = bigRadius;
					   data.r = data.r;
					   shrinkTransition(d3.select(this), data);
					   d3.select("#trackersBox").remove();
				   }
			   })
			   .on("mouseover", function(data) {
				   if (data.shrink != true) {
					   // Display a close button
					   svg.append("circle")
					      .attr("cx", d3.select(this).attr("cx"))
					      .attr("cy", d3.select(this).attr("cy")-d3.select(this).attr("r")*3/4)
					      .attr("r", d3.select(this).attr("r")/4)
					      .attr("fill", "white")
					      .attr("opacity", 0.7)
					      .attr("id", "closeButton")
					      .style("pointer-events", "none");
					   // Display a tooltip
					   categoryTooltip = svg.append("g")
					   						.attr("id", "categoryTooltip");
					   categoryTooltip.append("rect")
					   				  .attr("x", boxTopLeft[0])
					   				  .attr("y", boxTopLeft[1])
					   				  .attr("width", boxDimentions[0])
					   				  .attr("height", boxDimentions[1])
					   				  .attr("fill", "white")
					   				  .attr("stroke", "white");
					   drawTrackersList(categoryTooltip, data);
				   }
			   })
			   .on("mouseout", function() {
				   d3.select("#closeButton").remove();
				   d3.select("#categoryTooltip").remove();
			   });
		}
	</script>
</body>
</html>